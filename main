/* *********************************
 * Simple recursive descent parser *
 ***********************************/

/*
 * The output is an AST rather than a parse tree.
 *
 * Limitations: This is obviously no production-ready parser.  The
 * lexical analysis is primitive.  The error reporting is minimal and
 * in particular the parser does not make any attempt at recovering
 * from errors.
 */



/*
 - Need to implement type and scope checking on top of this parser for the assignment.
 - Result of program should be empty if both checks are correct
 - Should print errors messages for a type or scope error
 - Add more attributes and member functions to the AST nodes
 - No optimization for symbol table
 
 Your type checking should ensure the following:
 1. Type consistency for all expressions;
 2. Type consistency for all assignment statements;
 3. Integer and positive size in the declaration of all the arrays;
 4. Integer subscripts for all array access;
 5. All the variables are declared before use.
 
 
 ------What does this part mean?-----
 
 
 Note that the language is defined so that single-pass compilation is possible. However, you
 are not required to perform any syntax directed translation. You must leave the parser alone and
 pass the resulting parse tree to another function (or functions) that traverse it and realize the type
 and scope checking
 */

#include <list>
#include <string>
#include <sstream>
#include <iostream>
#include <unordered_set>
using namespace std;

/*
 * Gramar modified for recursive descent parsing (with e standing for
 * epsilon):

   <program>  ::= <block>
   <block>    ::= { <decls> <stmts> }
   <decls>    ::= e
                | <decl> <decls>
   <decl>     ::= <type> ID ;
   <type>     ::= BASIC <typecl>
   <typecl>   ::= e
                | [ NUM ] <typecl>
   <stmts>    ::= e
                | <stmt> <stmts>
   <stmt>     ::= <loc> = <bool> ;
                | IF ( <bool> ) <stmt>
                | IF ( <bool> ) <stmt> ELSE <stmt>
                | WHILE ( <bool> ) <stmt>
                | <block>
   <loc>      ::= ID <loccl>
   <loccl>    ::= e
                | [ <bool> ] <loccl>
   <bool>     ::= <join> <boolcl>
   <boolcl>   ::= e
                | || <join> <boolcl>
   <join>     ::= <equality> <joincl>
   <joincl>   ::= e
                | && <equality> <joincl>
   <equality> ::= <rel> <equalcl>
   <equalcl>  ::= e
                | == <rel> <equalcl>
                | != <rel> <equalcl>
   <rel>      ::= <expr> <reltail>
   <reltail>  ::= e
                | <= <expr>
                | >= <expr>
                | > <expr>
                | < <expr>
   <expr>     ::= <term> <exprcl>
   <exprcl>   ::= e
                | + <term> <exprcl>
                | - <term> <exprcl>
   <term>     ::= <unary> <termcl>
   <termcl>   ::= e
                | * <unary> <termcl>
                | / <unary> <termcl>
   <unary>    ::= ! <unary>
                | - <unary>
                | <factor>
   <factor>   ::= ( <bool> )
                | <loc>
                | NUM
                | REAL
                | TRUE
                | FALSE
 */

/*
 * Nonterminals (used to label the nodes in the parse tree):
 */
enum nonterminal {
    NT_TERMINAL,
    NT_PROGRAM,
    NT_BLOCK,
    NT_DECLS,
    NT_DECL,
    NT_TYPE,
    NT_TYPECL,
    NT_STMTS,
    NT_STMT,
    NT_LOC,
    NT_LOCCL,
    NT_BOOL,
    NT_BOOLCL,
    NT_JOIN,
    NT_JOINCL,
    NT_EQUALITY,
    NT_EQUALCL,
    NT_REL,
    NT_RELTAIL,
    NT_EXPR,
    NT_EXPRCL,
    NT_TERM,
    NT_TERMCL,
    NT_UNARY,
    NT_FACTOR
};

/*
 * Terminal types:
 */
enum vocab {
    VOC_EOS,
    VOC_OPEN_PAREN,
    VOC_CLS_PAREN,
    VOC_OPEN_BRACE,
    VOC_CLS_BRACE,
    VOC_OPEN_SQPAR,
    VOC_CLS_SQPAR,
    VOC_IF,
    VOC_ELSE,
    VOC_WHILE,
    VOC_ID,
    VOC_AND,
    VOC_OR,
    VOC_ASSIGN,
    VOC_EQ,
    VOC_NEQ,
    VOC_LTEQ,
    VOC_GTEQ,
    VOC_LT,
    VOC_GT,
    VOC_PLUS,
    VOC_MINUS,
    VOC_NUM,
    VOC_REAL,
    VOC_TRUE,
    VOC_FALSE,
    VOC_NOT,
    VOC_MUL,
    VOC_DIV,
    VOC_BASIC,
    VOC_SEMICOLON
};

/*
 Variable types for variables and functions
 */
enum type {
    // Basic Types
    TYPE_INT,
    TYPE_DOUBLE,
    TYPE_FLOAT,
    TYPE_CHAR,
    TYPE_STRING,
    TYPE_BOOL,
    TYPE_VOID,
    
    // Array Types
    TYPE_ARRAY,
    TYPE_INT_ARRAY,
    TYPE_DOUBLE_ARRAY,
    TYPE_FLOAT_ARRAY,
    TYPE_CHAR_ARRAY,
    TYPE_BOOL_ARRAY,
    
    // Expression Types
    TYPE_ARITHMETIC,
    TYPE_LOGICAL,
    TYPE_RELATIONAL,
    TYPE_EQUALITY,
    
    // Special Types
    TYPE_POINTER,
    TYPE_NULL,
    TYPE_ERROR,
    TYPE_UNKNOWN,
    
    // Control Flow Types
    TYPE_CONDITION,  // For if/while
    
    // Operation Types
    TYPE_ASSIGNMENT,
    TYPE_INDEX,      // For array indexing
};

class SymbolTable {
private:
    struct Symbol {
        string name;
        type varType;
        bool isArray;
        int arraySize;
        
        Symbol(string n, type t, bool arr = false, int size = 0)
                : name(n), varType(t), isArray(arr), arraySize(size) {
                    cout << "SymbolTable initialized." << endl;
                }
    };
    
    vector<Symbol> symbols;
    
public:
    
    void addSymbol(const string& name, type t, bool isArray = false, int arraySize = 0) {
        symbols.push_back(Symbol(name, t, isArray, arraySize));
    }
    
    type getType(const string& name) {
        cout << "Starting getType for: " << name << endl;
        cout << "Current Symbol Table:" << endl;
        for (const auto& sym : symbols) {
                cout << "Name: " << sym.name << ", Type: " << sym.varType << endl;
            }
        for (const auto& sym : symbols) {
                cout << "Checking symbol: " << sym.name << " against " << name << endl;  // Debugging
                if (sym.name == name) {
                    cout << "Symbol found: " << name << " with type " << sym.varType << endl;
                    return sym.varType;
                }
            }
            cout << "Symbol not found: " << name << endl;
            return TYPE_ERROR;
    }
    
    bool isArray(const string& name) {
        for(const auto& sym : symbols) {
            if(sym.name == name) {
                return sym.isArray;
            }
        }
        return false;
    }
    void print() const {
        for(const auto& sym : symbols) {
            string typeStr;
            switch(sym.varType) {
                case TYPE_INT: typeStr = "int"; break;
                case TYPE_DOUBLE: typeStr = "double"; break;
                case TYPE_FLOAT: typeStr = "float"; break;
                case TYPE_BOOL: typeStr = "bool"; break;
                case TYPE_CHAR: typeStr = "char"; break;
                default: typeStr = "unknown"; break;
            }
            cout << sym.name << "\t" << typeStr << "\t" << "     "<<(sym.isArray ? "yes" : "no") << "       "<< sym.arraySize << "\t" << endl;
        }
    }
};

SymbolTable symbolTable;

/*
 * Tokens are structures containing the actual string (the lexeme) and
 * also the type.
 */
struct token {
    string str;
    vocab type;
    token(string str, vocab tok) : str(str), type(tok) { }
    token() : type(VOC_EOS) { }
};

/*
 * Nodes in the parse tree.  The member variable nt contains the
 * nonterminal label for the node, or NT_TERMINAL if the node is
 * labelled with a terminal (or token).  For terminal nodes the member
 * variable term contains the respective token.
 *
 * Internal nodes are labelled with nonterminals while leaves are
 * labelled with either terminals (tokens) or nonterminals that were
 * rewritten to the empty string.
 */
class node {
    
private:
    token term;
    nonterminal nt;
    list<node*> children;
    
    //Private helper methods that identify proper type for nodes
    type getBasicType(const string& typeStr) const {
        if (typeStr == "int") return TYPE_INT;
        if (typeStr == "float") return TYPE_FLOAT;
        if (typeStr == "double") return TYPE_DOUBLE;
        if (typeStr == "bool") return TYPE_BOOL;
        if (typeStr == "char") return TYPE_CHAR;
        return TYPE_ERROR;
    }
    
    type getArrayType(type baseType) const {
            switch(baseType) {
                case TYPE_INT: return TYPE_INT_ARRAY;
                case TYPE_FLOAT: return TYPE_FLOAT_ARRAY;
                case TYPE_DOUBLE: return TYPE_DOUBLE_ARRAY;
                case TYPE_BOOL: return TYPE_BOOL_ARRAY;
                case TYPE_CHAR: return TYPE_CHAR_ARRAY;
                default: return TYPE_ERROR;
            }
        }

    type getLiteralType(vocab tokenType) const {
        switch(tokenType) {
            case VOC_NUM: return TYPE_INT;
            case VOC_REAL: return TYPE_DOUBLE;
            case VOC_TRUE: return TYPE_BOOL;
            case VOC_FALSE: return TYPE_BOOL;
            default: return TYPE_ERROR;
        }
    }

    type getExpressionType(nonterminal nodeType) const {
        switch(nodeType) {
            case NT_BOOL: return TYPE_BOOL;
            case NT_EXPR: return TYPE_ARITHMETIC;
            case NT_EQUALITY: return TYPE_EQUALITY;
            case NT_REL: return TYPE_RELATIONAL;
            default: return TYPE_ERROR;
        }
    }
public:
    //Constructors for nodes based on whether they are passed a non terminal or token
    node(nonterminal n) : nt(n) {  }
    node(token tok) : term(tok), nt(NT_TERMINAL) {  }
    
    //Getter for nonterminal labels
    nonterminal getNonTerminal() const {
        return nt;
    }
    //Getter for vocab types of tokens
    vocab getTermType() const{
        return term.type;
    }
    
    //Type of the node is given during the lexical analysis
    //Public method for fetching the node type that we can use for type checking
    //Each node has has an enum property nt that states what kind of node it is
    //This is as opposed to tokens which are specifically for leaf nodes and wouldn't allow us to verify the type of whole equations or assignations
    type getType() {
        cout << "switch for nt in getType: " << nt << endl;
        switch (nt) {
            case NT_TYPE: {
                cout << "Enter NT_TYPE" << endl;
                if (isToken() && (term.type == VOC_NUM || term.type == VOC_REAL ||
                                  term.type == VOC_TRUE || term.type == VOC_FALSE)) {
                    cout << "NT_TYPE with a literal, treating as literal type: " << term.str << endl;
                    return getLiteralType(term.type);
                }
                cout << "NT_TYPE returning: " << getBasicType(children.front()->term.str) << endl;
                return getBasicType(children.front()->term.str);
            }
            case NT_DECL:
                cout << "Enter NT_DECL" << endl;
                return children.front()->getType();

            case NT_LOC: {
                cout << "Enter NT_LOC" << endl;
                if (children.empty()) {
                    cout << "NT_LOC has no children!" << endl;
                    return TYPE_ERROR;
                }
                string varName = children.front()->printVal();
                cout << "Looking up variable: " << varName << endl;
                cout << "NT_LOC returning: " << symbolTable.getType(varName) << endl;
                return symbolTable.getType(varName);
            }
            case NT_FACTOR: {
                        cout << "Enter NT_FACTOR" << endl;
                        if (isToken()) {
                            cout << "NT_FACTOR returning terminal type: " << getLiteralType(term.type) << endl;
                            return getLiteralType(term.type);
                        }
                        if (!children.empty()) {
                            cout << "NT_FACTOR recursively checking child" << endl;
                            return children.front()->getType();
                        }
                        cout << "NT_FACTOR has no valid children, returning TYPE_ERROR" << endl;
                        return TYPE_ERROR;
                    }
           /* case NT_BOOL: {
                cout << "Enter NT_BOOL" << endl;
                if (children.empty()) {
                    cout << "NT_BOOL has no children!" << endl;
                    return TYPE_ERROR;
                }
                type joinType = children.front()->getType();  // Assume the first child is a join
                if (joinType == TYPE_BOOL) {
                    cout << "NT_BOOL returning TYPE_BOOL" << endl;
                    return TYPE_BOOL;
                }
                cout << "NT_BOOL returning TYPE_ERROR" << endl;
                return TYPE_ERROR;
            }*/
            /*
            case NT_JOIN: {
                cout << "Enter NT_JOIN" << endl;
                if (children.size() < 2) {
                    cout << "NT_JOIN has insufficient children!" << endl;
                    return TYPE_ERROR;
                }
                auto leftType = children.front()->getType();  // Left child
                auto rightType = children.back()->getType(); // Right child
                if (leftType == TYPE_BOOL && rightType == TYPE_BOOL) {
                    cout << "NT_JOIN returning TYPE_BOOL" << endl;
                    return TYPE_BOOL;
                }
                cout << "NT_JOIN returning TYPE_ERROR due to type mismatch" << endl;
                return TYPE_ERROR;
            }*/

            /*case NT_JOINCL: {
                cout << "Enter NT_JOINCL" << endl;
                if (children.empty()) {
                    cout << "NT_JOINCL has no children!" << endl;
                    return TYPE_ERROR;
                }
                for (auto child : children) {
                    if (child->getType() != TYPE_BOOL) {
                        cout << "NT_JOINCL returning TYPE_ERROR due to invalid child type" << endl;
                        return TYPE_ERROR;
                    }
                }
                cout << "NT_JOINCL returning TYPE_BOOL" << endl;
                return TYPE_BOOL;
            } */
                
            case NT_EXPR:
            case NT_TERM:
            case NT_UNARY:
            case NT_EQUALITY:
            case NT_REL:
            case NT_JOIN:
            case NT_BOOL:
            case NT_DECLS:
            case NT_STMTS:
            case NT_TYPECL:
            case NT_LOCCL:
            case NT_BOOLCL:
            case NT_JOINCL:
            case NT_EQUALCL:
            case NT_EXPRCL:
            case NT_TERMCL:
            case NT_RELTAIL: {
                cout << "Enter recursive case for nt: " << nt << endl;
                if (children.empty()) {
                    cout << "No children for nt: " << nt << ", returning TYPE_ERROR" << endl;
                    return TYPE_ERROR;
                }
                for (auto child : children) {
                    type childType = child->getType();
                    if (childType != TYPE_ERROR) {
                        cout << "Found valid type: " << childType << " for nt: " << nt << endl;
                        return childType;
                    }
                }
                cout << "All children returned TYPE_ERROR for nt: " << nt << endl;
                return TYPE_ERROR;
            }

            case NT_BLOCK: {
                cout << "Enter NT_BLOCK" << endl;
                if (children.empty()) {
                    cout << "NT_BLOCK has no children!" << endl;
                    return TYPE_ERROR;
                }
                cout << "NT_BLOCK delegating to first child" << endl;
                return children.front()->getType();
            }

            case NT_PROGRAM: {
                cout << "Enter NT_PROGRAM" << endl;
                if (children.empty()) {
                    cout << "NT_PROGRAM has no children!" << endl;
                    return TYPE_ERROR;
                }
                cout << "NT_PROGRAM delegating to first child" << endl;
                return children.front()->getType();
            }
            
            //Needs to stop once terminal node is encountered such as VOC_NUM, VOC_REAL this is after the <factor> node in the decent
            case NT_TERMINAL: {
                        cout << "Enter NT_TERMINAL" << endl;
                        return getLiteralType(term.type);
                    }

            default:
                cout << "getType returning TYPE_ERROR for nt: " << nt << endl;
                return TYPE_ERROR;
        }
    }
    
    
    ~node();

    void addChild(node* child) { children.push_back(child); }

    bool isToken() const { return nt == NT_TERMINAL; }
    bool isNonterminal() const { return !isToken(); }

    void print(unsigned indent) const;
    
    //A method that allows the export of the list of children
    const list<node*>& getChildren() const {
        return children;
    }
    
    string printVal() const;
    string printNonterminal(nonterminal) const;

};

node::~node() {
    for (list<node*>::const_iterator i = children.begin(); i != children.end(); ++i) {
        delete *i;
    }
}

/*
 * Pretty print functions.
 */

/*
 * Prints the value stored in the node (either nonterminal or token):
 */
string node::printVal() const {
    if (!isNonterminal()) {
        return term.str;
    } else {
        return printNonterminal(nt);
    }
}

/*
 * Provides strings for each nonterminal type:
 */
string node::printNonterminal(nonterminal nt) const {
    switch (nt) {
    case NT_PROGRAM:
        return "program";
    case NT_BLOCK:
        return "block";
    case NT_DECLS:
        return "decls";
    case NT_DECL:
        return "decl";
    case NT_TYPE:
        return "type";
    case NT_TYPECL:
        return "typecl";
    case NT_STMTS:
        return "stmts";
    case NT_STMT:
        return "stmt";
    case NT_LOC:
        return "loc";
    case NT_LOCCL:
        return "loccl";
    case NT_BOOL:
        return "bool";
    case NT_BOOLCL:
        return "boolcl";
    case NT_JOIN:
        return "join";
    case NT_JOINCL:
        return "joincl";
    case NT_EQUALITY:
        return "equality";
    case NT_EQUALCL:
        return "equalitycl";
    case NT_REL:
        return "rel";
    case NT_RELTAIL:
        return "reltail";
    case NT_EXPR:
        return "expr";
    case NT_EXPRCL:
        return "exprcl";
    case NT_TERM:
        return "term";
    case NT_TERMCL:
        return "termcl";
    case NT_UNARY:
        return "unary";
    case NT_FACTOR:
        return "factor";
    default:
        return "???";  // we will hopefully never reach this...
    }
}

/*
 * Pretty prints the whole parse tree recursively.
 */
void node::print(unsigned indent = 0) const {
    string symbol = printVal();
    if (isNonterminal())
        cout << string(indent, ' ') << "<" << symbol << ">" << '\n';
    else
        cout << string(indent, ' ') << symbol << '\n';
    for (list<node*>::const_iterator i = children.begin(); i != children.end(); ++i) {
        node* child = (*i);
        child->print(indent + 2);
    }
    if (isNonterminal())
        cout << string(indent, ' ') << "</" << symbol << ">" << '\n';
}



/********************
 * Lexical analysis *
 ********************/

/*
 * Determine whether a string represents a literal floating point.
 * Source: <http://stackoverflow.com/questions/5932391>.
 */
bool isDouble(string s) {
    std::istringstream iss(s);
    double d;
    char c;
    return iss >> d && !(iss >> c);
}
/*
 * Determine if a string is a literal int.
 * Source: <http://stackoverflow.com/questions/2844817>.
 */
bool isInteger(const std::string& s) {
    if (s.empty() || ((!isdigit(s[0])) && (s[0] != '-') && (s[0] != '+')))
        return false;
    char * p;
    strtol(s.c_str(), &p, 10);
    return (*p == 0);
}

/*
 * Main function for lexical analysis.
 */
token getToken() {
    string curr;

    if ( cin.eof() ) {
        return token();  // EOS on end of file
    }
    cin >> curr;
    if ( curr == "") {
        return token();  // EOS on end of file
    }

    // Special (fixed) tokens:
    if ( curr == "(" )
        return token(curr, VOC_OPEN_PAREN);
    if ( curr == ")" )
        return token(curr, VOC_CLS_PAREN);
    if ( curr == "{" )
        return token(curr, VOC_OPEN_BRACE);
    if ( curr == "}" )
        return token(curr, VOC_CLS_BRACE);
    if ( curr == "[" )
        return token(curr, VOC_OPEN_SQPAR);
    if ( curr == "]" )
        return token(curr, VOC_CLS_SQPAR);
    if ( curr == "if" )
        return token(curr, VOC_IF);
    if ( curr == "while" )
        return token(curr, VOC_WHILE);
    if ( curr == "else" )
        return token(curr, VOC_ELSE);
    if ( curr == "&&" )
        return token(curr, VOC_AND);
    if ( curr == "||" )
        return token(curr, VOC_OR);
    if ( curr == "=" )
        return token(curr, VOC_ASSIGN);
    if ( curr == "==" )
        return token(curr, VOC_EQ);
    if ( curr == "!=" )
        return token(curr, VOC_NEQ);
    if ( curr == "<=" )
        return token(curr, VOC_LTEQ);
    if ( curr == ">=" )
        return token(curr, VOC_GTEQ);
    if ( curr == "<" )
        return token(curr, VOC_LT);
    if ( curr == ">" )
        return token(curr, VOC_GT);
    if ( curr == "+" )
        return token(curr, VOC_PLUS);
    if ( curr == "-" )
        return token(curr, VOC_MINUS);
    if ( curr == "true" )
        return token(curr, VOC_TRUE);
    if ( curr == "false" )
        return token(curr, VOC_FALSE);
    if ( curr == "!" )
        return token(curr, VOC_NOT);
    if ( curr == "*" )
        return token(curr, VOC_MUL);
    if ( curr == "/" )
        return token(curr, VOC_DIV);
    if ( curr == ";" )
        return token(curr, VOC_SEMICOLON);
    if ( curr == "int" )
        return token(curr, VOC_BASIC);
    if ( curr == "char" )
        return token(curr, VOC_BASIC);
    if ( curr == "bool" )
        return token(curr, VOC_BASIC);
    if ( curr == "double" )
        return token(curr, VOC_BASIC);

    if (isInteger(curr)) {
        // Integer literal:
        return token(curr, VOC_NUM);
    }
    if (isDouble(curr)) {
        // Floating point literal:
        return token(curr, VOC_REAL);
    }

    // Everything else is an ID:
    return token(curr, VOC_ID);
}



/****************************
 * Recursive descent parser *
 ****************************/

/*
 * Current token throughout the parsing process.
 */
token tok;

/*
 * Compares the current token with the argument.  If they are the same
 * then obtains a new current token and returns.  Otherwise interrupts
 * the parser.
 */
void mustBe(vocab v) {
    if (v != tok.type) {
        cerr << "Unexpected token: " << tok.str << "\n";
        exit(1);
    }
    else tok = getToken();
}

/*
 * Nonterminal functions as per the grammar given at the beginning of
 * the file:
 */

node* Bool(); // forward declarations needed in Factor()
node* Loc();

// <factor>   ::= ( <bool> )
//              | <loc>
//              | NUM
//              | REAL
//              | TRUE
//              | FALSE
node* Factor() {
    node* current = new node (NT_FACTOR);
    switch(tok.type) {
    case VOC_NUM:
    case VOC_REAL:
    case VOC_TRUE:
    case VOC_FALSE:
        current -> addChild(new node (tok));
        tok = getToken();
        break;
    case VOC_ID:
        current -> addChild(Loc());
        break;
    default:
        mustBe(VOC_OPEN_PAREN);
        current -> addChild(Bool());
        mustBe(VOC_CLS_PAREN);
    }
    return current;
}

// <unary>    ::= ! <unary>
//              | - <unary>
//              | <factor>
node* Unary() {
    node* current = new node (NT_UNARY);
    switch(tok.type) {
    case VOC_NOT:
    case VOC_MINUS:
        current -> addChild(new node (tok));
        tok = getToken();
        current -> addChild(Unary());
        break;
    default:
        current -> addChild(Factor());
    }
    return current;
}

// <termcl>   ::= e
//              | * <unary> <termcl>
//              | / <unary> <termcl>
node* Termcl() {
    node* current = new node (NT_TERMCL);
    switch(tok.type) {
    case VOC_MUL:
    case VOC_DIV:
        current -> addChild(new node(tok));
        tok = getToken();
        current -> addChild(Unary());
        current -> addChild(Termcl());
        break;
    default:
        break;
    }
    return current;
}

// <term>     ::= <unary> <termcl>
node* Term() {
    node* current = new node (NT_TERM);
    current -> addChild(Unary());
    current -> addChild(Termcl());
    return current;
}

// <exprcl>   ::= e
//              | + <term> <exprcl>
//              | - <term> <exprcl>
node* Exprcl() {
    node* current = new node (NT_EXPRCL);
    switch(tok.type) {
    case VOC_PLUS:
    case VOC_MINUS:
        current -> addChild(new node(tok));
        tok = getToken();
        current -> addChild(Term());
        current -> addChild(Exprcl());
        break;
    default:
        break;
    }
    return current;
}

// <expr>     ::= <term> <exprcl>
node* Expr() {
    node* current = new node (NT_EXPR);
    current -> addChild(Term());
    current -> addChild(Exprcl());
    return current;
}

// <reltail>  ::= e
//              | <= <expr>
//              | >= <expr>
//              | > <expr>
//              | < <expr>
node* Reltail() {
    node* current = new node (NT_RELTAIL);
    switch(tok.type) {
    case VOC_LTEQ:
    case VOC_GTEQ:
    case VOC_LT:
    case VOC_GT:
        current -> addChild(new node(tok));
        tok = getToken();
        current -> addChild(Expr());
        break;
    default:
        break;
    }
    return current;
}

// <rel>      ::= <expr> <reltail>
node* Rel() {
    node* current = new node (NT_REL);
    current -> addChild(Expr());
    current -> addChild(Reltail());
    return current;
}

// <equalcl>  ::= e
//              | == <rel> <equalcl>
//              | != <rel> <equalcl>
node* Equalcl() {
    node* current = new node (NT_EQUALCL);
    switch(tok.type) {
    case VOC_EQ:
    case VOC_NEQ:
        current -> addChild(new node(tok));
        tok = getToken();
        current -> addChild(Rel());
        current -> addChild(Equalcl());
        break;
    default:
        break;
    }
    return current;
}

// <equality> ::= <rel> <equalcl>
node* Equality() {
    node* current = new node (NT_EQUALITY);
    current -> addChild(Rel());
    current -> addChild(Equalcl());
    return current;
}

// <joincl>   ::= e
//              | && <equality> <joincl>
node* Joincl() {
    node* current = new node (NT_JOINCL);
    switch(tok.type) {
    case VOC_AND:
        current -> addChild(new node(tok));
        tok = getToken();
        current -> addChild(Equality());
        current -> addChild(Joincl());
        break;
    default:
        break;
    }
    return current;
}

// <join>     ::= <equality> <joincl>
node* Join() {
    node* current = new node (NT_JOIN);
    current -> addChild(Equality());
    current -> addChild(Joincl());
    return current;
}

// <boolcl>   ::= e
//              | || <join> <boolcl>
node* Boolcl() {
    node* current = new node (NT_BOOLCL);
    switch(tok.type) {
    case VOC_OR:
        current -> addChild(new node(tok));
        tok = getToken();
        current -> addChild(Join());
        current -> addChild(Boolcl());
        break;
    default:
        break;
    }
    return current;
}

// <bool>     ::= <join> <boolcl>
node* Bool() {
    node* current = new node (NT_BOOL);
    current -> addChild(Join());
    current -> addChild(Boolcl());
    return current;
}

// <loccl>    ::= e
//              | [ <bool> ] <loccl>
node* Loccl() {
    node* current = new node (NT_LOCCL);
    switch(tok.type) {
    case VOC_OPEN_SQPAR:
        tok = getToken();
        current -> addChild(Bool());
        mustBe(VOC_CLS_SQPAR);
        current -> addChild(Loccl());
        break;
    default:
        break;
    }
    return current;
}

// <loc>      ::= ID <loccl>
node* Loc() {
    node* current = new node (NT_LOC);
    current -> addChild(new node(tok));
    mustBe(VOC_ID);
    current -> addChild(Loccl());
    return current;
}

node* Block(); // Forward declaration for Stmt()

// <stmt>     ::= <loc> = <bool> ;
//              | IF ( <bool> ) <stmt>
//              | IF ( <bool> ) <stmt> ELSE <stmt>
//              | WHILE ( <bool> ) <stmt>
//              | <block>
node* Stmt() {
    node* current = new node (NT_STMT);
    switch(tok.type) {
    case VOC_IF:
        current -> addChild(new node(tok));
        tok = getToken();
        mustBe(VOC_OPEN_PAREN);
        current -> addChild(Bool());
        mustBe(VOC_CLS_PAREN);
        current -> addChild(Stmt());
        if (tok.type == VOC_ELSE) {
            current -> addChild(new node(tok));
            tok = getToken();
            current -> addChild(Stmt());
        }
        break;
    case VOC_WHILE:
        current -> addChild(new node(tok));
        tok = getToken();
        mustBe(VOC_OPEN_PAREN);
        current -> addChild(Bool());
        mustBe(VOC_CLS_PAREN);
        current -> addChild(Stmt());
        break;
    case VOC_OPEN_BRACE:
        current -> addChild(Block());
        break;
    default:
        current -> addChild(Loc());
        current -> addChild(new node(tok));
        mustBe(VOC_ASSIGN);
        current -> addChild(Bool());
        mustBe(VOC_SEMICOLON);
        break;
    }
    return current;
}

// <stmts>    ::= e
//              | <stmt> <stmts>
node* Stmts() {
    node* current = new node (NT_STMTS);
    switch(tok.type) {
    case VOC_CLS_BRACE: // More concise to start with Follow(<stmts>)
        break;
    default:
        current -> addChild(Stmt());
        current -> addChild(Stmts());
        break;
    }
    return current;
}

// <typecl>   ::= e
//              | [ NUM ] <typecl>
node* Typecl() {
    node* current = new node (NT_TYPECL);
    switch(tok.type) {
    case VOC_OPEN_SQPAR:
        tok=getToken();
        current -> addChild(new node(tok));
        mustBe(VOC_NUM);
        mustBe(VOC_CLS_SQPAR);
        current -> addChild(Typecl());
        break;
    default:
        break;
    }
    return current;
}

// <type>     ::= BASIC <typecl>
node* Type() {
    node* current = new node (NT_TYPE);
    current -> addChild(new node(tok));
    mustBe(VOC_BASIC);
    current -> addChild(Typecl());
    return current;
}

// <decl>     ::= <type> ID ;
node* Decl() {
    node* current = new node (NT_DECL);
    current -> addChild(Type());
    current -> addChild(new node(tok));
    mustBe(VOC_ID);
    mustBe(VOC_SEMICOLON);
    return current;
}

// <decls>    ::= e
//              | <decl> <decls>
// Note: Follow(<decls>) = First(<stmt>) + Follow(<stmts>)
node* Decls() {
    node* current = new node (NT_DECLS);
    switch(tok.type) {
    case VOC_IF:
    case VOC_WHILE:
    case VOC_OPEN_BRACE:
    case VOC_ID:
    case VOC_CLS_BRACE:
        break;
    default:
        current -> addChild(Decl());
        current -> addChild(Decls());
        break;
    }
    return current;
}

// <block>    ::= { <decls> <stmts> }
node* Block() {
    node* current = new node (NT_BLOCK);
    mustBe(VOC_OPEN_BRACE);
    current -> addChild(Decls());
    current -> addChild(Stmts());
    mustBe(VOC_CLS_BRACE);
    return current;
}

// <program>  ::= <block>
node* Program() {
    node* current = new node (NT_PROGRAM);
    current -> addChild(Block());
    return current;
}

/*
 Type checking
 
 Perhaps this should be handled as a class
 
 if type handled improperly than print error type and change correctness value
 */
class TypeCheck
{
private:
    //Store reference to correctness of the types in the program from the main
    bool& typeCorrectness;
    
    node* leftNode = nullptr;
    node* rightNode = nullptr;
    //Helper methods for the check type method
    //Displaying error messages
    void reportError(const string& message) {
        cout << endl << "------------" << endl << "Type Error: " << message << endl;
        typeCorrectness = false;
    }
    
    bool checkAssignment(node* assignmentNode) {
        cout << "Checking assignment operation" << endl;

        // Extract LHS (left-hand side) and RHS (right-hand side) from the assignment node's children
        auto children = assignmentNode->getChildren();
        
        // The first child is the LHS (variable being assigned)
        node* lhsNode = children.front();

        // The last child is the RHS (value or expression being assigned)
        node* rhsNode = children.back();

        // Get the types of the LHS and RHS
        type lhsType = lhsNode->getType();
        type rhsType = rhsNode->getType();
        cout << lhsType << endl;
        cout << rhsType << endl;

        // Check if LHS is a valid variable or array element
        if (lhsNode->getNonTerminal() != NT_LOC) {
            reportError("Left-hand side of assignment is not a valid location");
            return false;
        }

        // Ensure the LHS variable exists in the symbol table
        string varName = lhsNode->getChildren().front()->printVal();
        if (!checkVariableExists(varName)) {
            return false;
        }
        /*
        // If RHS is a boolean expression, validate it
            if (lhsType == TYPE_BOOL && (rhsNode->getNonTerminal() == NT_BOOL || rhsNode->getNonTerminal() == NT_JOIN)) {
                if (!checkBooleanOperation(rhsNode)) {
                    reportError("Invalid boolean expression in assignment to: " + varName);
                    return false;
                }
            }*/

        // Check for type consistency between LHS and RHS
        if (lhsType != rhsType) {
            reportError("Type mismatch in assignment operation: " + varName +
                        " (" + to_string(lhsType) + ") cannot be assigned " +
                        to_string(rhsType));
            return false;
        }

        cout << "Assignment operation is valid" << endl;
        return true;
    }

    bool checkBooleanOperation(node* boolNode) {
        cout <<"---------boolean---------"<< endl;
        cout << "Checking boolean operation" << endl;
            // Default case: Invalid node
            reportError("Invalid boolean operation: non-terminal mismatch");
            return false;
        }
    bool checkArithmeticOperation(node* node) {
        cout << "Checking arithmetic operation" << endl;
        reportError("Error in Arithmatic Operation");
        return false;
    }

    bool checkRelationalOperation(node* node) {
        cout << "Checking relational operation" << endl;
        reportError("Error in Relational Operation");
        return false;
    }

    bool checkEqualityOperation(node* node) {
        cout << "Checking equality operation" << endl;
        reportError("Error in Equality Operation");
        return false;
    }

    bool checkArrayAccess(node* node) {
        cout << "Checking array access operation" << endl;
        reportError("Error in Array Access");
        return false;
    }

    bool checkArrayDeclaration(node* node) {
        cout << "Checking array declaration" << endl;
        reportError("Error in array declaration");
        return false;
    }
    
    //Check if array assignments have consistent types between between variable and array as well as between all indices of the array
    
    //Check for arithmetic op, relational op, equality op and logical op
    
    bool checkVariableExists(const string& varName) {
            if (symbolTable.getType(varName) == TYPE_ERROR) {
                reportError("Variable not declared: " + varName);
                return false;
            }
            return true;
        }

        // Handles type checking for factor nodes
        bool handleFactorChecking(node* tree) {
            // Only check factors that are locations (variables)
            
            if (!tree->getChildren().empty() &&
                tree->getChildren().front()->getNonTerminal() == NT_LOC) {
                string varName = tree->getChildren().front()->getChildren().front()->printVal();
                return checkVariableExists(varName);
            }
             
            cout << "handleFactorChecking" << endl;
            return true;
        }

        // Handles type checking for expressions
        bool handleExpressionChecking(node* tree) {
            
            auto children = tree->getChildren();
            for (node* child : children) {
                if (child->getNonTerminal() == NT_LOC) {
                    string varName = child->getChildren().front()->printVal();
                    if (!checkVariableExists(varName)) {
                        return false;
                    }
                    return checkArithmeticOperation(tree);
                }
            }
             
            cout<< "handleExpressionChecking" << endl;
            return true;
        }

        // Handles type checking for equality operations
        bool handleEqualityChecking(node* tree) {
            
            auto children = tree->getChildren();
            node* leftExpr = children.front();
            node* equalityCl = *(++children.begin());
            
            // Check left operand
            if (leftExpr->getNonTerminal() == NT_LOC) {
                string varName = leftExpr->getChildren().front()->printVal();
                if (!checkVariableExists(varName)) {
                    return false;
                }
            }
            
            // Check right operand if comparison exists
            if (!equalityCl->getChildren().empty()) {
                node* rightExpr = *(++equalityCl->getChildren().begin());
                if (rightExpr->getNonTerminal() == NT_LOC) {
                    string varName = rightExpr->getChildren().front()->printVal();
                    if (!checkVariableExists(varName)) {
                        return false;
                    }
                }
                return checkEqualityOperation(tree);
            }
             
            cout << "handleEqualityChecking" << endl;
            return true;
        }

        // Handles type checking for statements (assignments)
        bool handleStatementChecking(node* tree) {
            
            auto children = tree->getChildren();
            if (children.size() >= 3 && (*++children.begin())->getTermType() == VOC_ASSIGN) {
                node* leftNode = children.front();
                string varName = leftNode->getChildren().front()->printVal();
                
                if (!checkVariableExists(varName)) {
                    return false;
                }
                
                if (symbolTable.isArray(varName)) {
                    if (!checkArrayAccess(leftNode)) {
                        return false;
                    }
                }
                
                return checkAssignment(tree);
            }
             
            cout << "handleStatementChecking" << endl;
            cout << "checks for assignment" << endl;
            return true;
        }

        // Handles type checking for boolean operations
        bool handleBooleanChecking(node* tree) {
            
            auto children = tree->getChildren();
            for (node* child : children) {
                if (child->getNonTerminal() == NT_LOC) {
                    string varName = child->getChildren().front()->printVal();
                    if (!checkVariableExists(varName)) {
                        return false;
                    }
                    return checkBooleanOperation(tree);
                }
            }
             
            cout << "handleBooleanChecking" << endl;
            return true;
        }
    
    bool handleRelationalChecking(node* tree) {
        
            // Get the children nodes of the relational operation
            auto children = tree->getChildren();
            
            // In a relational operation, we have an expression and a reltail
            // The expression is the left side, and reltail contains the operator and right side if they exist
            node* leftExpr = children.front();
            node* reltail = *(++children.begin());
            
            // First check if the left expression contains a variable that needs checking
            if (leftExpr->getNonTerminal() == NT_LOC) {
                string varName = leftExpr->getChildren().front()->printVal();
                if (!checkVariableExists(varName)) {
                    return false;
                }
            }
            
            // If reltail has children, we have a relational operation to check
            // (If it's empty, there's no relational operator)
            if (!reltail->getChildren().empty()) {
                // The second child of reltail will be the right expression
                node* rightExpr = *(++reltail->getChildren().begin());
                
                // Check if right side contains a variable
                if (rightExpr->getNonTerminal() == NT_LOC) {
                    string varName = rightExpr->getChildren().front()->printVal();
                    if (!checkVariableExists(varName)) {
                        return false;
                    }
                }
                
                // After checking variable existence, verify the relational operation types
                return checkRelationalOperation(tree);
            }
            
        cout << "handleRelationalChecking" << endl;
            return true;
        }
    
public:
    void printSymbolTable() {
        cout << "\nSymbol Table Contents:" << endl;
        cout << "=====================" << endl;
        cout << "Name\tType\tIsArray\tArraySize" << endl;
        cout << "---------------------" << endl;
        
        // Access symbols through SymbolTable's new print method
        symbolTable.print();
    }
    //Constructor for tree (with specific cpp syntax for intializing variables with constructor
    TypeCheck(bool& correctness) : typeCorrectness(correctness) {}
    //Method that recursively decends the AST to (based on the grammar rules check the consistency of types across operations)
    void checkType(node* tree) {
        if (!tree) return;
            
            switch(tree->getNonTerminal()) {
                    /*
                     Needs to handle the array after getting example array code from prof know how to propeerly write for the parser --not in this way--
                     create placeholder method for adding array to symbol tree with decl
                     */
                case NT_DECL: {
                    cout << "Is handling declaration" << endl;
                    node* typeNode = tree->getChildren().front();
                    node* idNode = *(++tree->getChildren().begin());
                    type varType = typeNode->getType();
                    string varName = idNode->printVal();
                    
                    //Does not handle the case for array declaration
                    
                    cout << "Adding symbol: " << varName << " with type: " << varType << endl;
                    
                    //Declared variable is added to the symbol table
                    //symbolTable.addSymbol(varName, varType, false, 0);
                    symbolTable.addSymbol(varName, varType);
                    break;
                }

                
                case NT_STMT: {
                            handleStatementChecking(tree);
                            break;
                        }
                
                case NT_BOOL: {
                            handleBooleanChecking(tree);
                            break;
                        }
                        
                        case NT_REL: {
                            handleRelationalChecking(tree);
                            break;
                        }
                        
                        case NT_EXPR: {
                            handleExpressionChecking(tree);
                            break;
                        }
                        
                        case NT_FACTOR: {
                            handleFactorChecking(tree);
                            break;
                        }
                        
                        case NT_EQUALITY: {
                            handleEqualityChecking(tree);
                            break;
                        }
                default:
                    break;
            }

            for (node* child : tree->getChildren()) {
                checkType(child);
            }
        }
    
};
    //Be able to traverse the AST and perform type inference
    
    //Can perform a recursive traversal
    //To do this I need access to the children of the nodes which are private so I
    //Need to make a new method to access a reference to the list of children of a node
    //checkType(root.children, correctness)
    
    
    /* When I use the getChildren method to go through the children of root how do I need to keep these so that I can check the types.
     You check types by*/
    
    
    /*
     Needs to check types of variables and types of functions to ensure they have the proper returns
     */


/*
 Scope checking
 
 Perhaps this should be handled as a class
 
 if scope handled improperly than print error scope and change correctness value
 */
class ScopeCheck {
private:
    bool& scopeCorrectness;
    vector<unordered_set<string>> scopeStack;
    
    void reportError(const string& message) {
        cout << "Scope Error: " << message << endl;
        scopeCorrectness = false;
    }
    
    void enterScope() {
        cout << "enterScope" << endl;
        scopeStack.push_back(unordered_set<string>());
    }
    
    void exitScope() {
        cout << "exitScope" << endl;
        if (!scopeStack.empty()) {
            scopeStack.pop_back();
        }
    }

public:
    ScopeCheck(bool& correctness) : scopeCorrectness(correctness) {
        cout << "ScopeCheck" << endl;
        enterScope(); // Start with global scope
    }
    
    void checkScope(node* root) {
        cout << "checkScope" << endl;
        if (!root) return;
        
        switch(root->getNonTerminal()) {
            case NT_BLOCK: {
                enterScope();
                for (node* child : root->getChildren()) {
                    checkScope(child);
                }
                exitScope();
                break;
            }
            default:
                break;
        }
        
        if (root->getNonTerminal() != NT_BLOCK) {
            for (node* child : root->getChildren()) {
                checkScope(child);
            }
        }
    }
};

int main() {
    tok = getToken();
    node* tree = Program();  // Call the axiom function to parse
    mustBe(VOC_EOS);         /* That's how we know we have been successful!
    Must end successfully creation of the parse tree than we know the structure is okay*/
    
   //Here the 2 classes will be instantiated and the 2 member functions that check type and scope will be called
    
    bool typeCorrectness = true;
    bool scopeCorrectness = true;
    
    cout << "Type Checking sequence:" << endl;
    TypeCheck typeCheck(typeCorrectness);
    typeCheck.checkType(tree);
    cout << "Scope Checking sequence:" << endl;
    ScopeCheck scopeCheck(scopeCorrectness);
    scopeCheck.checkScope(tree);
    
    typeCheck.printSymbolTable();
    
    if (tree) {
        cout << "Lexical Analysis sequence:" << endl;
        tree->print();
        delete tree;
        return 0;
    }
    else
        return 1;
}

